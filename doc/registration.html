<HTML>
<HEAD>
<TITLE>
XParam - General-Purpose Object Serialization Framework for C++
</TITLE>
</HEAD>
<BODY>
<CENTER>
<H1>
XParam - General-Purpose Object Serialization Framework for C++
</H1>
<H2>
The XParam Library User's Guide
</H2>
</CENTER>
<H3>
The Registration Interface
</H3>
Next: <A HREF="installation.html">Installing XParam</A><BR>
Previous: <A HREF="programmer.html">The Programmer Interface</A><BR>
Up: <A HREF="index.html">Table of Contents</A><BR>
<P>
Contents:
<OL>
<LI><A HREF="#general">General</A></LI>
<LI><A HREF="#basicstructure">The Basic Structure</A></LI>
<LI><A HREF="#classdeclarations">Class Declarations</A></LI>
<LI><A HREF="#inheritance">Inheritance</A></LI>
<LI><A HREF="#constants">Constants</A></LI>
<LI><A HREF="#enumerators">Enumerators</A></LI>
<LI><A HREF="#argumentpassers">Argument Passers</A></LI>
<LI><A HREF="#constructors">Constructors</A></LI>
<LI><A HREF="#creators">Creators</A></LI>
<LI><A HREF="#conversions">Conversions</A></LI>
<LI><A HREF="#vectors">Vectors, Lists, Sets, Maps and Pairs</A></LI>
<LI><A HREF="#output">Output</A></LI>
<LI><A HREF="#hvl">HVL, TypedValueMap and RawBytes</A></LI>
<LI><A HREF="#dynamicloading">Dynamic Loading</A></LI>
<LI><A HREF="#pending">Checking for Blocked Registration Calls</A></LI>
<LI><A HREF="#extension">Creating Template Registration Commands</A></LI>
</OL>
<P>
<A NAME="general"><H4>General</H4></A>
The most involved and least frequently required interface to the
XParam library is the registration interface. In contrast to the
user's interface, that is required whenever a program using
XParam is invoked, and the programmer's interface, that should be
used whenever you write a new program with XParam parameter
handling, registration is needed only when you want XParam to
learn how to use new classes, or when the interface to an already
registered class has changed.
<P>
In principle, to handle user inputs such as <TT>a=7</TT>, where <TT>a</TT> is,
for example, an instance of class <TT>Duck</TT>, XParam should find the
best path from <TT>7</TT> to a <TT>Duck</TT> variable. If <TT>Duck</TT> has
a non-explicit constructor from <TT>int</TT>, that can, of course, be used.
If, instead, it only has a non-explicit constructor from <TT>double</TT>,
then the <TT>7</TT> integer should be converted to a <TT>double</TT>, and
from there to <TT>Duck</TT>. If, on the other hand, the only non-explicit
constructor <TT>Duck</TT> has is from <TT>char</TT>, then the
<TT>7</TT> should not be taken as an integer value at all, but
as an abbreviation of <TT>'7'</TT>, using XParam's relaxed
type matching. This was only a very simple example, but arbitrarily complex
implicit conversion paths can also be generated by the user.
Consider, for example, the user's command mentioned in the
introduction:
<P>
<TT>
~/bin&gt;a.out 'my_shape=[ Circle(Point(50,50),50), Circle(Point(25,75),10),
Circle(Point(75,75),10), Arc(Point(25,50), Point(50,25), Point(75,50)) ]'
</TT>
<P>
To parse this line correctly, XParam needs considerable knowledge of the
existing classes and the inter-connections between them.
<P>
All the information required by XParam exists as part of the classes'
interface. Unfortunately, because C++ has no reflection capability,
in the registration process the registrator has to make this
information explicitly available for XParam's usage. As will shortly
be demonstrated, the registration process itself is entirely
non-intrusive, enabling third-party registration. The only restriction
XParam-registered classes have is that if they are concrete,
they should support a public copy constructor and be assignable.
Because of this,
classes can be developed by one person, entirely unaware of XParam,
then registered by a second person and finally used by a third person.
For this to be possible, the class interface, developed by the first
person, should be available for the registering person, and code
developed by the registrator and the programmer should be linked
together (though it can be compiled separately) into the running
program.
<P>
To emphasize this point, consider that in order to run
the example quoted above, classes <TT>Circle</TT>, <TT>Arc</TT>
and <TT>Point</TT> weren't necessarily even programmed at the time
the main program was compiled and even executed. Trying to parse the
command-line, XParam can dynamically load both the registration code
and the class implementations at run-time.
<P>
<A NAME="basicstructure"><H4>The Basic Structure</H4></A>
In the next sections, the exact contents of registration files will
be elaborated, but the basic structure of all registration files is
exactly the same. First, note that XParam's registration files, as
was hinted at in the first section, are C++ files. They should be
compiled as any C++ file and linked with the rest of your program.
This can be confusing, because registration files don't look like
they are C++-compilable files. What they do look like, is this:
<P>
<PRE>
#include &lt;xparam_extend.h&gt;
#include "point.h"
#include "point_output.h"
using namespace xParam;

PARAM_BEGIN_REG

  PARAM_CLASS(Point);
    param_ctor&lt;Point&gt;(ByVal&lt;int&gt;("x"),ByVal&lt;int&gt;("y"));
    param_output&lt;Point,Point_output_functor&gt;();
    param_vector&lt;Point&gt;();

PARAM_END_REG
</PRE>
<P>
To understand this format, let's go over it line by line:
<P>
<TT>
#include &lt;xparam_extend.h&gt;
</TT>
<P>
This file contains the declarations needed for XParam registration.
<P>
<TT>
#include "point.h"
</TT>
<P>
The interface of the registered class should be visible to the
registration code.
<P>
<TT>
#include "point_output.h"
</TT>
<P>
In this particular case, we separated the implementation of
<TT>Point</TT>'s output to a different file.
Consult the section about <A HREF="#creators">Creators</A> to
learn about other header files you may want to <TT>#include</TT>
to your registration code.
<P>
<TT>
using namespace xParam;
</TT>
<P>
You don't need this line, of course, but if you don't use it,
you will have to add the <TT>xParam::</TT> prefix to virtually
everything in the registration code, so we highly recommend it.
All our examples of registration code will assume the inclusion
of this line.
<P>
Finally, we reach the registration code itself. It is denoted by
a <TT>PARAM_BEGIN_REG</TT>/<TT>PARAM_END_REG</TT> block. The
purpose of this block is to create an environment in which commands
are executed before <TT>main()</TT> is entered. The two macros set up an
anonymous namespace and define a class within that namespace,
and an instance of the class. The commands placed inside a
<TT>PARAM_BEGIN_REG</TT>/<TT>PARAM_END_REG</TT> block compose
the class's constructor, and are therefore executed.
All XParam's registration commands are simple function calls and
constructors for temporary objects. The
<TT>PARAM_BEGIN_REG</TT>/<TT>PARAM_END_REG</TT> block allows these
function calls to be executed and the registration to take effect
before <TT>main()</TT> is reached.
<P>
You can, of course, run the registration commands by other means,
but it is our opinion that this is the simplest and most
straightforward way.
<P>
One <TT>PARAM_BEGIN_REG</TT>/<TT>PARAM_END_REG</TT> pair is good
to put all your registration commands
in, but if you want you can separate your registration commands
into as many blocks as you want. This can be effective if you
want to put ordinary C++ code in your registration files. The
<TT>Point_output_functor</TT>, for example, could have been written
directly in the <TT>Point</TT> registration file, and splitting
the file into several registration blocks can help you place the
output functor near the registration command relevant to it.
<P>
An XParam program can link in as many registration files as it
wishes, and as many classes as you wish can be registered in the
same registration block.
<P>
Ordinary C++ code should not be placed inside a registration
block, unless you want it to run prior to your <TT>main()</TT>.
<P>
In the next section we will go over all the registration
commands supplied by XParam for use in registration blocks.
<P>
Note: it is not an error to repeat a registration call more than once, as
long as the repetitions are exact duplicates. XParam will recognize the
repetition and will ignore all but the first registration call.
<A NAME="classdeclarations"><H4>Class Declarations</H4></A>
The usual way to declare a class for XParam's use is
<P>
<TT>
PARAM_CLASS(<I>my_class</I>);
</TT>
<P>
<TT>PARAM_CLASS</TT> is a macro. If you rather not use this
macro, you can always opt for the longer form:
<P>
<TT>
param_class&lt;<I>my_class</I>&gt;("<I>my_class</I>");
</TT>
<P>
which is what the previous line expands to. This format is
usually not used, unless you want your class to be given a
different name in its XParam user interface than it does in
C++. Though this may seem like a strange idea at first, take
into account that fully qualified class names are used much
more frequently in XParam than they are in C++ code, so it
is convenient to use a shorter form here. Here is one
example of such a usage, in XParam's own <TT>cpp</TT> files:
<P>
<TT>
param_class&lt;std::string&gt;("string");
</TT>
<P>
The STL string, known inside C++ programs as <TT>std::string</TT>, and
sometimes even as <TT>std::basic_string&lt;char, std::char_traits&lt;char&gt;,
std::allocator&lt;char&gt; &gt;</TT> would have been cumbersome to
use under that name. Therefore, the XParam name it has been
given is simply <TT>string</TT>. XParam would have been able to
handle this fully qualified name. However, no XParam class name can
include a modifier, such as "unsigned", "long", "const", "static" or
"volatile". (See the exception to this rule, later on in this section.)
<P>
One other reason not to use the macro is when your class-name has
a comma in it, such as "Position&lt;int,int&gt;". If you try to use the
PARAM_CLASS macro with this name, it will complain that the macro
was invoked with too many parameters, because the macro can not
correctly parse this expression. In such a case, use non-macro
registration.
<P>
Because XParam tries to instantiate its classes, abstract classes can
not be registered in this way. They use
<P>
<TT>
PARAM_ABSTRACT_CLASS(<I>my_abstract_class</I>);
</TT>
<P>
which is a macro that expands to
<P>
<TT>
param_abstract_class&lt;<I>my_abstract_class</I>&gt;("<I>my_abstract_class</I>");
</TT>
<P>
Registering abstract classes is useful for using polymorphism, where
inheritance relationships are necessary.
<P>
The following types have been pre-registered by XParam. The name in
parentheses indicates the XParam-name of the class, if it differs from
the C++ name.
<UL>
<LI>bool</LI>
<LI>char</LI>
<LI>double</LI>
<LI>float</LI>
<LI>int</LI>
<LI>long</LI>
<LI>short</LI>
<LI>std::string (string)</LI>
<LI>unsigned char (uchar)</LI>
<LI>unsigned int (uint)</LI>
<LI>unsigned long (ulong)</LI>
<LI>unsigned short (ushort)</LI>
</UL>
In addition, for platforms which support these, XParam also provides
<UL>
<LI>long long (longlong)</LI>
<LI>unsigned long long (ulonglong)</LI>
<LI>long double (long_double)</LI>
</UL>
<P>
Though you can register any
template specialization you want, not every template specialization
is a legal XParam name. Currently, XParam can only
handle template specializations which expect class names as their
specialization parameters. That is: <TT>Matrix&lt;int&gt;</TT> is
allowed, but <TT>Matrix&lt;3,4&gt;</TT> isn't. If you want to use class
<TT>Matrix&lt;3,4&gt;</TT>, you can, but not under that name. Here is
one possible workaround:
<P>
<TT>
param_class&lt;Matrix&lt;3,4&gt; &gt;("Matrix&lt;THREE,FOUR&gt;");
</TT>
<P>
There are two exceptions to the "no modifiers are allowed in class names"
rule: when registering a template specialization, classes that are
part of the specialization description can include the modifier "const"
and a "*" if they are pointer types,
but no other modifier. For example: <TT>vector&lt;const string*&gt;</TT>
is a legal XParam class name, and one can therefore register it
directly using the registration macro:
<P>
<TT>
PARAM_CLASS(vector&lt;const string*&gt;);
</TT>
<A NAME="inheritance"><H4>Inheritance</H4></A>
In addition to the registration of the existance of your classes,
XParam allows you to register other properties. Here is the
syntax to register an inheritance relationship between two classes:
<P>
<TT>
param_inheritance(DerivedTag&lt;<I>my_derived_class</I>&gt;(),
BaseTag&lt;<I>my_base_class</I>&gt;());
</TT>
<P>
The syntax includes <TT>DerivedTag</TT> and <TT>BaseTag</TT> so
as to minimize the possibility of confusion in the registration
order.
<P>
Just as in C++, if A derives from B and B derives from C, then
A derives from C. You do not need to register the A-from-C
relationship explicitly.
<P>
Note: The entire registration process is meant to register class
interfaces. If your class has private or protected inheritance from
a base class, this is naturally not a part of the class interface,
and you should therefore not register it. Another very important
detail to note about registering inheritances is that all classes
involved in an XParam inheritance relationship must have at least
one virtual method (even if it is the destructor). This makes C++
create a virtual method pointer table for the class, enables
real-time type information for the class, allows use of
<TT>dynamic_cast</TT>s, and, in general, allows XParam to make
proper use of the inheritance information.

<A NAME="constants"><H4>Constants</H4></A>
Defining a constant, so that it will be recognized in XParam
initializations, is very simple. The registration command is:
<P>
<TT>
param_const(<I>name</I>,<I>value</I>);
</TT>
<P>
where <I>name</I> is a string, and <I>value</I> can be a C++
variable of any type which has been registered into XParam.
XParam does not insist that your variable will be defined as
'const'. However, the value that this variable had at
registration time is the value that XParam will use.
<P>
The constant will be of the same type as that of the C++ variable.
In XParam initializations, the constant will be recognized by the
name given in <I>name</I>.
<P>
Usually, the name you will want to give your constant is the same
as the name you reference it in your C++ programs. To accomplish
this, XParam defines an easy interface using the PARAM_CONST
macro.
<P>
<TT>
PARAM_CONST(<I>variable</I>);
</TT>
<P>
expands to
<P>
<TT>
param_const("<I>variable</I>",<I>variable</I>);
</TT>
<P>
Note: It is not recommended to use dynamically loaded constants.
Though XParam does support loading constants dynamically, using
a constant in a parameter initialization will not trigger dynamic
loading. XParam will only recognize the constant if it had
already been loaded due to a missing class that had to be
dynamically loaded. For this reason, it is safest to have all your
constants statically linked to your program.
<!--
Starting version 1.21 of XParam, constants can have scope qualifications,
so the name "std::numeric_limits&lt;double&gt;::quiet_NaN" is a legal name
for an XParam constant.
-->
<P>
<A NAME="enumerators"><H4>Enumerators</H4></A>
Enumerators are handled in a very similar way to constants.
First, you need to register your enum type. This is done by the
macro
<P>
<TT>
PARAM_ENUM(<I>enum_type</I>);
</TT>
<P>
or, alternatively, by an explicit call to the registration function
it expands to:
<P>
<TT>
param_enum&lt;<I>enum_type</I>&gt;("<I>enum_type_name_in_XParam</I>");
</TT>
<P>
or, for an ISO-challanged compiler:
<P>
<TT>
param_enum(TypeTag&lt;<I>enum_type</I>&gt;(),"<I>enum_type_name_in_XParam</I>");
</TT>
<P>
The macro naturally assumes that you want to set the name of the enum_type
in XParam to be exactly what it is in C++.
<P>
To define a certain instance of your enum, all you have to do is use the
macro
<P>
<TT>
PARAM_ENUM_VAL(<I>value</I>);
</TT>
<P>
or the function it expands to:
<P>
<TT>
param_enum_val("<I>value_name_in_XParam</I>", <I>value</I>);
</TT>
where the value's name in C++ and the value's name in XParam are assumed
to be the same.
<P>
If this sounds complex, here is an example that will make it clearer:
<P>
<PRE>
enum DOW { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday };

PARAM_BEGIN_REG
  PARAM_ENUM(DOW);
  PARAM_ENUM_VAL(Monday);
  PARAM_ENUM_VAL(Tuesday);
  PARAM_ENUM_VAL(Wednesday);
  PARAM_ENUM_VAL(Thursday);
  PARAM_ENUM_VAL(Friday);
  PARAM_ENUM_VAL(Saturday);
  PARAM_ENUM_VAL(Sunday);
PARAM_END_REG
</PRE>
<P>
That's all there is to it! The enumerator is now ready to be read from the
input as if it were a regular constant. Note, however, that there is a
difference between constants and enums in the way they are output: constants
are output by their values, so if the programmer was to write
"cout &lt;&lt; Val(M_PI)", she can expect to get "3.1415" on the output line.
Enums, on the other hand, are output by name. Writing "cout &lt;&lt; Wednesday",
will result in "Wednesday" being output, so that re-reading
the enum elsewhere will still give the value of Wednesday, even if the enum
is defined by a different integer there.
<P>
An exception to this rule are enums that were not declared by the registrator.
If, in the registration process, you registered "PARAM_ENUM(DOW);", but did
not continue to register its instances -- something we wholeheartedly
discourage -- then anyone who tries writing "cout &lt;&lt; Wednesday" will get
"DOW(2)" in the output. Though this still works, and can even be read back
using XParam (assuming Wednesday is still represented by the number 2 in the DOW
list of the reading program) it is much less clear to a human reader, and
may be less portable. For this reason, it is always advisable to register
all your enum values.
<!--
Starting version 1.21 of XParam, enums can have scope qualifications,
so the name "std::ios&lt;char&gt;::cur" is a legal name
for an XParam enumerator.
-->
<P>
<A NAME="argumentpassers"><H4>Argument Passers</H4></A>
Most of the registration code is composed of registration of
constructors. This, in general, looks something like this:
<P>
<TT>
param_ctor&lt;Point&gt;(ByVal&lt;int&gt;("x"),ByVal&lt;int&gt;("y"));
</TT>
<P>
This particular line means: class <TT>Point</TT> has a
constructor from two integers, x and y, both passed by value.
As you can see, a major part of the description is composed
of argument passers: <TT>ByVal&lt;int&gt;("x")</TT> is the
XParam way of saying "an argument called <TT>x</TT>, of type
<TT>int</TT>, which is passed by value". In this section
we will go over the various argument passers supplied by
XParam and how to use them.
<P>
In XParam, arguments can be passed by value, by
constant reference or by pointer. If it is
passed by pointer, an argument can be constant or
non-constant, and the responsibility to delete it after
the end of the construction call can lie either with the
caller, or with the called constructor. This gives four
different types of pointers. In addition to this, there
are two more argument passers: AsConvertedVal and
AsCString. These will be explained later on.
<P>
An XParam argument, with the exception of AsConvertedVal and
AsCString, takes the following form:
<P>
<TT>
<I>passmode</I>&lt;<I>type</I>&gt;("<I>argname</I>")
</TT>
<P>
for example:
<P>
<TT>
ByVal&lt;int&gt;("width")
</TT>
<P>
This means: the argument's name is <TT>width</TT>,
its type is <TT>int</TT> and it should be passed
by value. The argument's name is currently only used for
error reporting and getting help, but may become more functional
in future XParam versions.
<P>
Instead of <TT>ByVal</TT>, you can put <TT>ConstRef</TT>
to indicate an argument passed by constant reference,
<TT>ClassPtr</TT> and <TT>CallerPtr</TT> to indicate a
pointer that is owned by the method it was passed to
or one that is owned by the caller and should be deleted by
XParam, respectively, and <TT>ClassConstPtr</TT> and
<TT>CallerConstPtr</TT>, which are the constant
pointer equivalents of <TT>ClassPtr</TT> and <TT>CallerPtr</TT>.
<P>
XParam pointers are all allocated by <TT>new</TT>, so
<TT>ClassPtr</TT> and <TT>ClassConstPtr</TT> should be
deallocated by using <TT>delete</TT> in the called
method.
<P>
One special case is a constructor expecting a C-string
(i.e. a null-terminated array of <TT>char</TT>s). XParam handles
strings in a very different way than C++ does. C++ considers
an explicit string literal to be of type C-string. Type C-string
is equivalent to an array of <TT>char</TT>s, and different than an
<TT>std::string</TT>. In XParam, an explicit string literal is considered
to be of type <TT>std::string</TT>. For this reason, if class
<TT>Duck</TT> has a constructor from an <TT>std::string</TT>,
and <TT>my_duck</TT> is an instance of <TT>Duck</TT>, then
<P>
<TT>
my_duck="abc"
</TT>
<P>
is a legal XParam initialization. In C++, this would have required
two implicit user-defined casts: one from C-string to <TT>std::string</TT>,
the other from <TT>std::string</TT> to <TT>Duck</TT>.
<P>
On the other hand, unlike C++, XParam considers the types
<TT>std::string</TT>, C-string and [<TT>const</TT>] <TT>char*</TT>
to be completely unrelated
types. In previous examples, we have shown how to pass, in XParam,
arguments of any class type (using <TT>ByVal</TT> and <TT>ConstRef</TT>)
as well as any pointer type. In this way, it is possible to pass either
an <TT>std::string</TT> or a [<TT>const</TT>] pointer to a <TT>char</TT>.
However, these will not do if you want your constructor to accept
a C-string parameter. To do this, write
<P>
<TT>
AsCString("<I>argname</I>")
</TT>
<P>
Finally, if you need, for some reason, to allow an
implicit conversion at pass-time, and your compiler
warns you about this, you can use
<P>
<TT>
AsConvertedVal&lt;<I>sourcetype</I>,<I>destinationtype</I>&gt;("<I>argname</I>");
</TT>
<P>
This should hardly ever be needed. However, XParam's
pre-registered types use this, because implicit
conversions between almost all built-in C types are
allowed by the language.
<A NAME="constructors"><H4>Constructors</H4></A>
Now that we've gone over argument passing, here's
the syntax to register constructors:
<P>
<TT>
param_ctor&lt;<I>registered_type</I>&gt;(<I> .. list of
argument passers ... </I>);
</TT>
<P>
The list of argument passers can contain between
zero and thirteen arguments (XParam does not support
methods with more than thirteen arguments, by default.
This can be changed. See the <A HREF="installation.html">
installation</A> section for details).
The arguments should have the format described in
the previous section. Arguments in the list should
be separated by commas.
<P>
For example:
<P>
<TT>param_ctor&lt;Complex&gt;();</TT> is the default Complex constructor.<BR>
<TT>param_ctor&lt;Complex&gt;(ByVal&lt;double&gt;("real"));</TT>
is the double-to-Complex implicit conversion constructor.<BR>
<TT>param_ctor&lt;Complex&gt;(ByVal&lt;double&gt;("real"),
ByVal&lt;double&gt;("imaginary"));</TT> is the
Complex-from-two-doubles constructor.
<P>
Unfortunately, though this is ISO-C++, many compilers
still balk at this syntax. For this reason,
XParam is also willing to accept the following format
for registering constructors:
<P>
<TT>
param_ctor(TypeTag&lt;<I>registered_type</I>&gt;(), <I>... arglist ... </I>);
</TT>
<P>
In XParam, as in C++, constructors can also be declared
"explicit", to prevent their usage in implicit conversion
paths. To register this, use the single-argument
constructor, in either flavor, switching <TT>param_ctor</TT>
with <TT>param_explicit_ctor</TT>. So, if we do not
wish the Complex-from-double constructor to be allowed
implicitly, all we need is to register it as
<P>
<TT>
param_explicit_ctor&lt;Complex&gt;(ByVal&lt;double&gt;("real"));<BR>
</TT>
or<BR>
<TT>
param_explicit_ctor(TypeTag&lt;Complex&gt;(),
ByVal&lt;double&gt;("real"));
</TT>
<P>
Because XParam requires that all concrete classes have copy
constructors, this constructor is registered automatically
when you use "param_class" to register a concrete class.
<A NAME="creators"><H4>Creators</H4></A>
Not always is everything handed to us on a silver platter.
One of the many surprises life can have in store for you
is that the class you wish to register does not support
the interface you need.
<P>
How can that be? you ask. Well, many classes don't allow
themselves to be set up completely at construction-time.
You build them up in a certain way, and then need a little
more tweaking to get it exactly right. Consider, for example,
the <TT>std::vector</TT>. If you want a vector of integers to be
filled with the numbers one through five, in C++, this is the
way to do it:
<P>
<TT>
std::vector&lt;int&gt; v;<BR>
v.push_back(1);<BR>
v.push_back(2);<BR>
v.push_back(3);<BR>
v.push_back(4);<BR>
v.push_back(5);<BR>
</TT>
<P>
In XParam, however, you want to do everything on a single
construction line. The person who wrote the C++ interface
could have omitted the possibility for complete construction
on a single line because she didn't think it too important,
or because (as in the case of <TT>std::vector</TT>) the appropriate
constructor isn't possible to program in C++. Either way,
XParam may have a solution for you.
<P>
What you need to do is to program a creator. A creator is
a functor class supporting the following interface:
<P>
<PRE>
class <I>creator_name</I> {
  public:
    static <I>created_class_name</I>* create(<I> ... arglist ... </I>);
};
</PRE>
<P>
where <TT>arglist</TT> is the list of arguments you want
to send to the creator functor. It is composed of normal
C++ arguments, not XParam argument passers.
<P>
Here's an example: a friend of mine programmed the following struct:
<P>
<PRE>
struct Point {
  int x,y;
};
</PRE>
<P>
In C++, using this struct is no problem: you take a "Point" variable
and assign whatever value you want to it. However, in XParam you want
the initialization to be done right on the object definition line.
You therefore want to register the following creation functor:
<P>
<PRE>
class Point_creator {
  public:
    static Point* create(const int _x, const int _y) {
      Point* rc=new Point;
      rc->x=_x;
      rc->y=_y;
      return rc;
    }
};
</PRE>
<P>
Make sure that in your creator the pointer to your created type is
allocated using <TT>new</TT>.
<P>
Once the functor is set up, all you need to do is to register it:
<P>
<TT>
param_creator&lt;Point,Point_creator&gt;
(ByVal&lt;int&gt;("_x"),ByVal&lt;int&gt;("_y"));
</TT>
<P>
or, for an ISO-challenged compiler:
<P>
<TT>
param_creator(TypeTag&lt;Point&gt;(),TypeTag&lt;Point_creator&gt;(),
ByVal&lt;int&gt;("_x"),ByVal&lt;int&gt;("_y"));
</TT>
<P>
This example was perhaps a little contrived, but was given here
for simplicity. Here is a real life usage:
<P>
Starting with version 1.2 of XParam, <TT>std::map</TT>s and
<TT>std::pair</TT>s have very
simple-to-use functions for registering them. However, people wanting to
register the <TT>std::map&lt;std::string,int&gt;</TT> prior to version 1.2
would have had to work a little harder to do so, because all registration
calls would have had to be done manually. Here is how to register the
creator of such a map from an explicit listing of its contents in the form
<TT>std::vector&lt;std::pair&lt;std::string,int&gt; &gt;</TT>.
What we need to do is to program the following class:
<P>
<PRE>
class map_creator {
  public:
    static std::map&lt;std::string,int&gt;*
     create(const std::vector&lt;std::pair&lt;std::string,int&gt; &gt;&amp; v);
};
</PRE>
<P>
with the method implementation being, for example, this:
<P>
<PRE>
using namespace std;

static map&lt;string,int&gt;*
map_creator::create(const vector&lt;pair&lt;string,int&gt; &gt;&amp; v) {
      typedef map&lt;string,int&gt; maptype;
      typedef vector&lt;pair&lt;string,int&gt; &gt; vectype;

      maptype* rc=new maptype();
      for(vectype::const_iterator i=v.begin();i!=v.end();++i) {
        (*rc)[i-&gt;first]=i-&gt;second;
      }
      return rc;
}
</PRE>
<P>
Armed with this, all you need is the following registration
command (assuming the rest of map, vector and pair have already
been registered):
<P>
<TT>
using namespace std;<BR>
param_creator&lt;map&lt;string,int&gt;,
map_creator&gt(ConstRef&lt;vector&lt;pair&lt;string,int&gt;
&gt; &gt;("v"));
</TT>
<P>
Or, for an ISO challenged compiler:
<P>
<TT>
using namespace std;<BR>
param_creator(TypeTag&lt;map&lt;string,int&gt; &gt;(),
TypeTag&lt;map_creator&gt;(),
ConstRef&lt;vector&lt;pair&lt;string,int&gt; &gt; &gt;("v"));
</TT>
<P>
As constructors, XParam creators, too, can be declared to be
"explicit". This is done by switching <TT>param_creator</TT>
with <TT>param_explicit_creator</TT>
<P>
In general, the syntax for creator registration is the following:
<P>
<TT>param_creator&lt;<I>my_class</I>,<I>my_class_creator</I>&gt;(<I>...
arglist ...</I>);</TT><BR>
or<BR>
<TT>param_creator(TypeTag&lt;<I>my_class</I>&gt;(),
TypeTag&lt;<I>my_class_creator</I>&gt;(),<I>... arglist ...</I>);</TT><BR>
or<BR>
<TT>param_explicit_creator&lt;<I>my_class</I>,
<I>my_class_creator</I>&gt;(<I>arg</I>);
</TT><BR>
or<BR>
<TT>param_explicit_creator(TypeTag&lt;<I>my_class</I>&gt;(),
TypeTag&lt;<I>my_class_creator</I>&gt;(),<I>arg</I>);</TT><BR>
<P>
The <TT><I>arg</I></TT> and <TT><I>arglist</I></TT>, of course, are the XParam
argument-passers list that matches the argument list
given in the functor.
<P>
When registering a creator, an output function, or any other
functional object, in XParam, the registered class, or at least
its interface, must be visible to the registration code.
For this reason, if you separate the functors from the registration
code, you will want to <TT>#include</TT> their header files in
the registration file.
<P>
In the <A HREF="programmer.html">Programmer Interface</A>
section, we mentioned the fact that, unlike in C++, XParam
does not allow you to register two constructors for ClassA,
one from a pointer to ClassB, the other from a constant
reference to ClassB. This is because XParam uses the
same syntax to signify both. If you encounter this problem,
or any other reason why XParam does not allow you to register
the constructors that you want to use, you may want to use
creators as a workaround. Consider, for example, this
creator functional object:
<P>
<PRE>
class workaround {
  public:
    static ClassA* create(const ClassB* const b, const Dummy&amp;) {
      return new ClassA(b);
    }
};
</PRE>
<P>
If you register it, you will be able to use the
Class-A-from-ClassB-pointer constructor by invoking this
creator, which receives an extra "Dummy" parameter.
If you already have the ClassA-from-const-ClassB-reference constructor
and class "Dummy" registered, this workaround allows you to
use the user syntax <TT>a=ClassB(...)</TT> to signify the
construction of ClassA from a ClassB const reference (assuming
<TT>a</TT> is a paramter of type ClassA), and to use
<TT>a=ClassA(ClassB(...),Dummy())</TT> to signify a
ClassA-from-ClassB-pointer construction. Such workarounds
are hardly ever needed, but it is useful to know they can
be used in the unlikely case you're going to need them.
<P>
Note: there is a more elegant way of working around this problem,
and it doesn't utilize creators at all. Programming in C++,
you may sometimes find yourself adding a dummy class to your
program in order to solve an ambiguity. For example, you may
want to add the class "Length" to your program, simply to
differentiate between <TT>Vector(7)</TT> and <TT>Vector(Length(7))</TT>.
The same solution works in XParam: program and register class
WorkaroundPtr that has an explicit constructor from a
"const ClassB* const" and a conversion operator to a "ClassA".
Using it, you'll be able to differentiate between
<P>
<TT>
a=ClassA(ClassB(...))
</TT>
<P>
indicating a construction from a "ClassB" constant reference, and
<P>
<TT>
a=ClassA(WorkaroundPtr(ClassB(...))
</TT>
<P>
indicating a construction from a "ClassB*" pointer.
<A NAME="conversions"><H4>Conversions</H4></A>
In C++, one can define a conversion either in the form of a
conversion constructor, or in the form of a conversion
operator. Both because these have slightly different
behaviors, and because we wanted to keep the conceptual
difference that the C++ language makes, XParam also
allows the registration of conversion operators. These
have the following format:
<P>
<TT>
param_conversion_operator(SourceTag&lt;<I>source_type</I>&gt;(),
TargetTag&lt;<I>target_type</I>&gt;());
</TT>
<P>
<A NAME="vectors"><H4>Vectors, Lists, Sets, Maps and Pairs</H4></A>
It is impossible, in XParam, to register templates directly.
However, it is possible to register template instantiations.
So, for
example, one can not register the template <TT>std::vector</TT>,
but one can register any of its specializations, such as
<TT>std::vector&lt;int&gt;</TT> and <TT>std::vector&lt;Duck&gt;</TT>.
<P>
For some of the basic STL templates, XParam provides registration
commands that allow you to register an instantiation in a single
command. These commands are not much more than functions that
run all the relevant registration commands. The STL templates
for which XParam provides this functionality are:
<UL>
<LI>std::vector&lt;<I>T</I>&gt; (vector&lt;<I>T</I>&gt;)</LI>
<LI>std::list&lt;<I>T</I>&gt; (list&lt;<I>T</I>&gt;)</LI>
<LI>std::set&lt;<I>T</I>&gt; (set&lt;<I>T</I>&gt;)</LI>
<LI>std::map&lt;<I>KeyType</I>,<I>ValueType</I>&gt;
(map&lt;<I>KeyType</I>,<I>ValueType</I>&gt;)</LI>
<LI>std::pair&lt;<I>FirstType</I>,<I>SecondType</I>&gt;
(pair&lt;<I>FirstType</I>,<I>SecondType</I>&gt;)
</LI>
</UL>
where the names in parentheses are the XParam names given to these C++
types, in which the "std::" prefix has been omitted for convenience.
<P>
The command to register an <TT>std::vector</TT> over a type <TT><I>T</I></TT>
is:
<P>
<TT>
param_vector&lt;<I>T</I>&gt;();
</TT>
<P>
Registering <TT>std::vector&lt;<I>T</I>*&gt;</TT> and
<TT>std::vector&lt;const <I>T</I>*&gt;</TT> is done by these two commands,
respectively:
<P>
<TT>
param_ptr_vector&lt;<I>T</I>&gt;();<BR>
</TT>
and<BR>
<TT>
param_const_ptr_vector&lt;<I>T</I>&gt;();<BR>
</TT>
<P>
Registration commands for <TT>std::list</TT> are analogous to those
provided for <TT>std::vector</TT>. They are:
<P>
<TT>
param_list&lt;<I>my_class</I>&gt;();<BR>
param_ptr_list&lt;<I>my_class</I>&gt;();<BR>
param_const_ptr_list&lt;<I>my_class</I>&gt;();
</TT>
<P>
Registration of <TT>std::map</TT> is done using the following
commands:
<P>
<TT>
param_map&lt;<I>KeyType</I>,<I>ValueType</I>&gt;();<BR>
param_ptr_map&lt;<I>KeyType</I>,<I>ValueType</I>&gt;();<BR>
param_const_ptr_map&lt;<I>KeyType</I>,<I>ValueType</I>&gt;();
</TT>
<P>
which register the classes
<TT>std::map&lt;<I>KeyType</I>,<I>ValueType</I>&gt;</TT>,
<TT>std::map&lt;<I>KeyType</I>,<I>ValueType</I>*&gt;</TT>,
and <TT>std::map&lt;<I>KeyType</I>,const <I>ValueType</I>*&gt;</TT>
respectively.
<P>
For <TT>std::set</TT> use the command
<P>
<TT>
param_set&lt;<I>my_class</I>&gt;();
</TT>
<P>
Finally, registration of <TT>std::pair</TT> has the following syntax:
<P>
<TT>
param_pair&lt;<I>FirstType</I>,<I>SecondType</I>&gt;();
</TT>
<P>
All the registration commands mentioned in this section assume that the
types over which the templates are built (e.g. the scalar type of the
<TT>std::vector</TT>) have been registered elsewhere in the program.
They do not attempt to register them on their own.
<P>
Note: XParam pre-registers the <TT>std::vector&lt;<I>T</I>&gt;</TT> for
all built-in types as well as for the <TT>std::string</TT>.
<A NAME="output"><H4>Output</H4></A>
All the sections, so far, have dealt with input, i.e.
with the question of how user-input, whether from the
command-line, from file or piped-in from another program,
should be parsed and made into real, live, working
objects. This section is different, because here you
specify how you want XParam classes to serialize
themselves back to a streamable output form, so that
you can save them in a file, print them or e-mail
them to your congress member.
<P>
The XParam output registration command is very simple:
<P>
<TT>
param_output&lt;<I>my_class</I>, <I>my_class_output_functor</I>&gt;();
</TT>
<P>
It is very similar to the registration of creators, but
differs in the fact that there is no argument list, and
that there is no need for a variation with <TT>TypeTag</TT>s.
Any modern C++ compiler should be able to handle this
form. (This is because it doesn't use explicit template
function arguments. It is simply a constructor call.)
<P>
This command registers an output functor for your class.
However, you still need to supply the functor itself. To
understand what this functor is and what it does better,
recall that XParam outputs its variables in such a way
that they are readable by XParam, in case you want to
read them again from a different program or in a different
time. So, XParam must be able to output a <TT>Triangle</TT>,
for example, in the following format:
<P>
<TT>
Triangle(Point(5,6),Point(7,8),Point(10,1))
</TT>
<P>
Naturally, this calls for a recursive approach. The output
functor of class <TT>Triangle</TT> should tell XParam which
three points should be output in order to describe this
triangle, at which point XParam will recursively have to
find out how to output a Point and finally how to output
an integer. Neither of the latter two should be supplied
by the <TT>Triangle</TT> class. It only needs to tell
XParam which three <TT>Point</TT> objects compose it.
Here's how this is done:
<P>
<PRE>
class Triangle_output_functor {
  public:
    static ValueList sub_objects(const Triangle&amp; t) {
      ValueList vl;
      return vl &lt;&lt; Val(t.p1) &lt;&lt; Val(t.p2) &lt;&lt; Val(t.p3);
    }
};
</PRE>
<P>
The interface of the output functor is always the same:
it must support a public static method called <TT>sub_objects</TT>
that receives a constant reference to the output variable
and returns a variable of type <TT>ValueList</TT>. The
way to fill this <TT>ValueList</TT> with the correct
information is to construct it with a default constructor,
and then to use
<P>
<TT>
ValueList&amp; operator&lt;&lt;(ValueList&amp;,const Handle&lt;ValueSource&gt;&amp;);
</TT>
<P>
to append to it the sub-objects that compose the object to
be printed.
<P>
After you register an output functor, it's a good idea to
go back and check that you really do have a constructor
that matches the output function, so that variables that have
been serialized and then deserialized will return exactly to
their original state. It can be very confusing if they
don't.
<P>
We recommend supplying output capability to all classes you
register. This will make the debugging process much more
painless for both you and the programmer, and will make class
usage much more convenient to the user (because class output
is used in much of XParam's help-giving and error-handling
mechanisms). If you don't, any
attempt to serialize the class and output it will result in
<P>
<TT>
<I>classname</I>(NO OUTPUT FUNCTION)
</TT>
<P>
Which is not readable as input to another program using XParam
parameter handling.
<A NAME="hvl"><H4>HVL, TypedValueMap and RawBytes</H4></A>
<A HREF="user.html">The User Interface</A> part of this manual describes
special syntax available for the initialization of vectors, lists, sets and
maps. It allows the user
of these classes to explicitly list their contents on a single initialization
line, something that is impossible in C++.
<P>
This is not really a special property of lists, vectors, sets and maps. You can
make your classes behave this way, too, if you want your classes to be
able to be initialized with a non-predetermined number of parameters.
What happens behind the scenes is
that each of these special interfaces is handled by a class (or rather, a
class template) that XParam is familiar with. The syntax
<P>
<TT>
[ element, element, element ]
</TT>
<P>
actually initializes a variable of type <TT>xParam::HVL&lt;T&gt;</TT>, where
T is the type of the element values. ("HVL" stands for "Homogenous Value
List".) We simply provide <TT>std::list</TT>
and <TT>std::vector</TT> a creator from this type. You can program such
a creator for your classes as well. Similarly, <TT>std::vector</TT>,
<TT>std::set</TT> and
<TT>std::list</TT>, when output, create an <TT>HVL</TT> that holds their
data and output it as their single sub-object. This creates the same syntax in
the output of these types.
<P>
The syntax
<P>
<TT>
{ key1 =&gt; val1, key2 =&gt; val2, key3 =&gt; val3 }
</TT>
<P>
Works in precisely the same way. It is really the syntax for the template
class <TT>xParam::TypedValueMap&lt;KeyType,ValueType&gt;</TT>. We provided
a creator and an output functor for the <TT>std::map</TT>.
<P>
Initializing your classes in the same way is not difficult, but it does
take some understanding of these XParam template classes.
<P>
When you're creating your class from an HVL, you can treat it as a
container, holding pointers of your element type. XParam does not actually
use pointers -- It uses smart pointers -- but the "-&gt;" and "*" syntax
will work as usual for you to retrieve your elements. The container itself
holds all the functionality of an <TT>std::vector</TT>.
<P>
When creating an HVL from your class, in order to output your class, use
the method
<P>
<TT>
void append_copy(const T* t_ptr);
</TT>
<P>
This will append a copy of the element pointed to into the HVL.
<P>
To clarify, here is a simplified version of the output functor of the
<TT>std::vector</TT>, as defined in XParam's own code:
<P>
<PRE>
template&lt;class T&gt;
class VectorOutput {
public:
  static ValueList sub_objects(const std::vector&lt;T&gt;&amp; vec) {
    HVL&lt;T&gt; hvl;
    typename std::vector&lt;T&gt;::const_iterator i;
    for(i=vec.begin(); i!=vec.end(); ++i) {
      hvl.append_copy(i);
    }
    ValueList vl;
    vl &lt;&lt; Val(hvl);
    return vl;
  }
};
</PRE>
<P>
The <TT>TypedValueMap</TT> is very similar to the <TT>HVL</TT>.
Its version of <TT>append_copy</TT> looks like this:
<P>
<TT>
void append_copy(const KEY&amp; key, const VALUE* val_ptr);
</TT>
<P>
When building an object from a TypedValueMap, you can consider it as
a container holding a struct with two pointers, one called "key",
and the other called "value". The container holds all the functionality
of an <TT>std::vector</TT>. Here, too, XParam does not really use
pointers, but the "-&gt;" and "*" syntax will work as expected.
<P>
Note: in XParam internals, the TypedValueMap is, infact, considered to be a
special case of an HVL. This causes some unexpected behaviors, if you're
really trying hard to make them happen. In particular, there are rare
cases where a class expecting a "[ ... ]" will be initializeable by a
"{ ... }", and there is a way to simulate the "{ ... }" syntax using
only square brackets. Consider these to be undocumented features and
their useage hazardous at best. Assume that they will not be supported
in any future version.
<P>
One final note: if all this is too complicated for you, you can always
resort to initializing your classes from a vector or from a list.
The disadvantages of this method are:
<OL>
<LI>The conversion weight associated with converting from the special
syntax to your class will be higher. If you're not sure what the
consequences of this are, look at the
<A HREF="conversions.html">Conversion Rules</A> appendix of this manual.</LI>
<LI>The performance will be suboptimal when initializing your class,
because of all the copying taking place. In future versions, we expect the
initializtion using the HVL/TypedValueMap to become more rigorously
optimized, and the differences will soar.</LI>
<LI>Your class will not look as good in output.</LI>
</OL>
One last special syntax available in XParam initializations is the
<P>
<PRE>
raw&lt;&lt;&lt; ... &gt;&gt;&gt;
</PRE>
<P>
format. This indicates a binary dump of data, meant for machine-machine
communication (which is why it isn't considered part of the user interface).
<P>
This format translates to a class of type <TT>RawBytes</TT> that can be used
in your initializations and serializations. A complete overview of
<TT>RawBytes</TT> is provided in the
<A HREF="programmer.html#rawbytes">RawBytes</A> section of
<A HREF="programmer.html">The Programmer Interface</A>.
<A NAME="dynamicloading"><H4>Dynamic Loading</H4></A>
We have already mentioned that XParam can load classes,
including their registration information, dynamically.
<P>
In order to do this, XParam must have the information of
what to load when a certain class is needed. This information
should be supplied in the form of an <TT>XPN</TT> file. An
<TT>XPN</TT> file is a file with an <TT>xpn</TT> extension
which contains one or more
<P>
<TT>[class1, class2] =&gt; [file1, file2]</TT>
<P>
sequences. The particular line in the example states that
if either <TT>class1</TT> or <TT>class2</TT> is needed,
<TT>file1</TT> and <TT>file2</TT> should both be dynamically
loaded. Any amount of white-space can be added in the
<TT>XPN</TT> files, except in the middle of a class name literal, a
file name, or the <TT>=&gt;</TT> symbol. If a list of
classes contains only one class, the brackets around it may
be omitted. Likewise if the file list contains only a
single file, the brackets around its name may be omitted.
<TT>XPN</TT> files may also contain single line comments,
these being lines beginning with the character '#'.
<P>
You may have as many <TT>XPN</TT> files as you want, and
place them in any directory you want (as long as it is
accessible to XParam). However, the full list of all
directories containing <TT>XPN</TT> files should be available
in the environment variable <TT>XPARAM_CLASSPATH</TT>.
<P>
In the <A HREF="examples.html">Usage Examples</A> section, a program
using dynamic loading is demonstrated.
<P>
Note: XParam currently does not support dynamic loading under Windows.
You must link in your classes and their registration commands statically,
instead.
<A NAME="pending"><H4>Checking for Blocked Registration Calls</H4></A>
As you may have noted, certain registration calls require other registration
calls as prerequisites. When, for example, you register that <TT>class A</TT>
is a derived type from <TT>class B</TT>, XParam expects both <TT>class A</TT>
and <TT>class B</TT> to be correctly registered.
<P>
In C++, it is impossible to determine in which order the registration
commands will be processed. To overcome this difficulty, XParam employs a
technique we call "delayed registration". Essentially, delayed registration
means that when you ask XParam to register the inheritance relationship, it does
not automatically do so, but rather defers the registration until such time
when all of its dependence conditions (e.g. the registration of <TT>class A</TT>
and the registration of <TT>class B</TT>) will be fulfilled.
<P>
For this reason, if you omit the registration call for one of your classes,
this will cause XParam to defer indefinitely all registration calls pertaining
to it, and, effectively, this will cause all these registration calls to be
completely ignored.
<P>
Registration commands that have already been enqued, but which are yet to be
executed because they lack their prerequisites are referred to, in XParam, as
"pending" registration calls. To make sure that none of your registration
calls remains pending after all registration commands have been processed
(which means that some class registration call has been forgotten) use the
command
<P>
<TT>
xparam_help("PENDING");
</TT>
<P>
This will return a string describing all pending registration commands.
<P>
This information is also accessible from the command-line. Simply type
<P>
<TT>
<I>myprog</I> ! PENDING
</TT>
<P>
to have the same string printed as the program output. The program will halt
after printing. This interface is useful in debugging your registration calls.
If everything goes well, at the end of the registration process, the "PENDING"
directive should return "No registration commands are pending."
<A NAME="extension"><H4>Creating Template Registration Commands</H4></A>
As has been mentioned before, it is impossible to directly register
a template into XParam, but it is possible to register template instantiations.
In the section regarding
<A HREF="#vectors">Vectors, Lists, Sets, Maps and Pairs</A>
we have shown several registration commands that allow you, on a single line,
to register an entire template instantiation. In this section, we will explain
how you can create registration commands for your own templates, in the same
way. This is a rather advanced way of using XParam, and we recommend that you
first gain some practice in manual registration, before attempting this
automatization.
<P>
After reading this section, you may want to refer to the file
<TT>xpv_reg_pair.h</TT>, which is part of XParam's include files. This file
implements the registration command <TT>param_pair</TT>. This command
is fully implemented only using syntax described here and open for your
usage.
<P>
The other registration commands available in XParam which register template
instantiations (<TT>vector</TT>s, <TT>list</TT>s, <TT>set</TT>s
and <TT>map</TT>s)
use a small amount of syntax not yet exported to the XParam registrator. This is
meant in order to register vectors (etc.) of elements, pointers to elements
and const pointers to elements all in the same class. It is very simple
to register all these classes without the benefit of this added syntax.
The files registering these classes (<TT>xpv_reg_vector.h</TT>,
<TT>xpv_reg_list.h</TT>, <TT>xpv_reg_set.h</TT>
and <TT>xpv_reg_map.h</TT>) can therefore also
serve as good sources to learn from.
<P>
In essence, creating your own registration call for a template instantiation
involves two steps:
<OL>
<LI>Implement a <TT>RegCommand</TT> class, such that objects of this class
can be enqued
along with the rest of the registration commands, and will be able to perform
the actual registration when all prerequisites are registered.</LI>
<LI>Create a registration interface.</LI>
</OL>
The first of these two steps involves inheriting from
<TT>ClassRegCommand&lt;<I>ClassName</I>&gt;</TT>, where
<TT><I>ClassName</I></TT> is the name of the class you want to register.
<P>
Note: the full name of <TT>ClassRegCommand</TT> is
<P>
<TT>
template&lt;class T, class ClassKind=ConcreteClassKind&lt;T&gt; &gt;
class ClassRegCommand
</TT>
<P>
If the template you wish to register is a template of abstract classes, instead
of inheriting from <TT>ClassRegCommand&lt;<I>ClassName</I>&gt;</TT>, inherit
from
<P>
<TT>
ClassRegCommand&lt;<I>ClassName</I>,
AbstractClassKind&lt;<I>ClassName</I>&gt; &gt;
</TT>
<P>
In inheriting, you must specify which other classes are prerequisites for the
registration of this class, and will probably want to override the method
<P>
<TT>
virtual std::string type_name(void) const;
</TT>
<P>
which should return the XParam name of the class you are registering.
<P>
Specifying dependencies is done at the construction of <TT>ClassRegCommand</TT>.
<TT>ClassRegCommand</TT> can be constructed in one of three ways. The simplest
way is by
<P>
<TT>
ClassRegCommand(const std::string&amp; name);
</TT>
<P>
This constructor is meant for classes which have no dependencies, and
whose name can be given using an explicit string. Though this is the
constructor used in the <TT>param_class</TT> registration command, it is
most likely that you will not be able to make use of it in registering
templates, because virtually all template classes will need to depend,
somewhere, on the types that are their template parameters. The <TT>pair</TT>
class template, for example, depends on its two sub-types for both its
constructors and its output function.
<P>
Note: this is the only constructor available for <TT>ClassRegCommand</TT> where
the class name is given in the constructor. In all other cases, you will
need to override the <TT>type_name</TT> method of <TT>ClassRegCommand</TT>.
<P>
The second way to construct a ClassRegCommand is
<P>
<TT>
ClassRegCommand(const std::vector&lt;const std::type_info*&gt;&amp; deps);
</TT>
<P>
This vector contains the <TT>type_info</TT>s of all classes that your class
depends on, for its correct registration. Though this is the most generic
interface to <TT>ClassRegCommand</TT>, you normally don't need more than
one or two prerequisites for your class. In this case, you can opt for the
third way to construct a <TT>ClassRegCommand</TT>. The third way is to
use the <TT>type_info</TT>s of the classes your registration depends on
directly as the constructor arguments for the <TT>ClassRegCommand</TT>.
XParam supports this for zero, one and two dependencies. Here is the
relevant constructor for two depenedencies:
<P>
<TT>
ClassRegCommand(const std::type_info&amp; dep1, const std::type_info&amp; dep2);
</TT>
<P>
Now that we have correctly set the dependencies for our new class, it is
time to give it a name. This is done by overriding the <TT>type_name</TT>
method of <TT>ClassRegCommand</TT>. Here is the implementation of the
<TT>type_name</TT> method for pair:
<P>
<PRE>
template&lt;class X, class Y&gt;
virtual std::string PairRegCommand&lt;X,Y&gt;::type_name(void) const {
  return "pair&lt;"
         + xparam_or_cpp_name(typeid(X))
         + ","
         + xparam_or_cpp_name(typeid(Y))
         + "&gt;";
}
</PRE>
<P>
XParam can not and does not check whether all possible instantiations of your
registration class will yield legal XParam type names. However, when this
class is instantiated, the type name it yields is checked, and if it is not
legal, an error is thrown.
<P>
Note, in the <TT>PairRegCommand</TT> implementation, the use of
<TT>xparam_or_cpp_name</TT>. <TT>xparam_or_cpp_name</TT> is the correct
way to refer to the names of other classes in the <TT>type_name</TT> method.
This function normally behaves like <TT>xparam_name</TT>, which is the
behavior you would normally want and expect when giving names to your
templates. However, the <TT>type_name</TT> method also has another usage:
it is used in reporting errors. In error reporting, especially
when the error occurs during the registration process, it is impossible to
guarantee that the sub-classes will already be registered.
<TT>xparam_or_cpp_name</TT> attempts to return the <TT>xparam_name</TT>,
but if it is not yet registered, it returns the C++
<TT>type_name</TT>, instead.
<P>
Using <TT>xparam_name</TT> in this context is a mistake, because attempting
to print an error message regarding the template instantiation will trigger
an attempt to access the information of its subclasses, which may trigger
dynamic loading, force other registration calls to be executed, and,
ultimately, cause you not to receive the error message which caused it all.
<P>
Once your RegCommand class is correctly defined, it is time for the second
step of registering a template: define a registration interface appropriate
for your template.
<P>
All of XParam's registration commands are either template functions or
definitions of an anonymous variable of a template class, where all
registration commands are enqued in the constructor. The same format can
be used for your extensions, as well.
<P>
<TT>param_pair</TT> for example is a template class. Its constructor calls
<TT>param_class</TT> to register the new class, <TT>param_ctor</TT> to
register a constructor for it, and <TT>param_output</TT> to register its
output function. This is all that is required in order to fully register
a new instance of the <TT>std::pair</TT> template.
<P>
Note, however, that in running the relevant <TT>param_class</TT> registration
command we don't want to use the simple form
<P>
<TT>
param_class&lt;<I>ClassName</I>&gt;("<I>ClassNameInXParam</I>");
</TT>
<P>
Instead, we opt to register our new type's <TT>RegCommand</TT>. This is done
by a different interface to the same registration command:
<P>
<TT>
param_class&lt;<I>ClassName</I>&gt;(ClassRegCommand&lt;<I>ClassName</I>&gt;*);
</TT>
<P>
(<TT>param_abstract_class</TT>, too, has an analogous interface.)
<P>
Note that <TT>param_class</TT> receives ownership over this pointer, and it
is <TT>param_class</TT>'s responsibility to free its memory, when it is done.
This is done using the <TT>delete</TT> command. You should not access the
pointer after it has been passed to <TT>param_class</TT>.
<P>
One typical way to make sure that the pointer passed to <TT>param_class</TT>
is not accessed anywhere else in the program is to allocate it while passing
it to <TT>param_class</TT>. Here's how this is done in the constructor of
<TT>param_pair&lt;X,Y&gt;</TT>:
<P>
<TT>
param_class&lt;Pair&gt;(new PairRegCommand&lt;X,Y&gt;());
</TT>
<P>
Next: <A HREF="installation.html">Installing XParam</A><BR>
Previous: <A HREF="programmer.html">The Programmer Interface</A><BR>
Up: <A HREF="index.html">Table of Contents</A><BR>
</BODY>
</HTML>

